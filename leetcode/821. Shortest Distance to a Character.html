<body>
  <script>
    /**
     * @param {string} S
     * @param {character} C
     * @return {number[]}
     */
    var shortestToChar = function (S, C) {
      const ans = []
      for (let i = 0; i < S.length; i++) {
        ans[i] = Math.min(
          S.lastIndexOf(C, i) === -1
            ? Infinity
            : i - S.lastIndexOf(C, i),
          S.indexOf(C, i) === -1
            ? Infinity
            : S.indexOf(C, i) - i
        )
      }
      return ans
    }

    var solution = function (S, C) {
      const indexArr = [],
        len = S.length,
        ans = Array(len).fill(len)
      for (let i = 0; i < len; i++) {
        if (S[i] === C) indexArr.push(i)
      }
      for (let i = 0; i < len; i++) {
        if (S[i] === C) {
          ans[i] = 0
          continue
        }
        for (const index of indexArr) {
          const dist = Math.abs(index - i)
          if (dist >= ans[i]) break
          ans[i] = dist
        }
      }
      return ans
    }

    // 这里取巧用了api，尝试自己写个indexOf & lastIndexOf
    function myIndexOf(S, C, fromIndex = 0) {
      const len = S.length
      for (let i = fromIndex; i < len; i++) {
        if (S[i] === C) return i
      }
      return -1
    }

    function myLastIndexOf(S, C, fromIndex) {
      const len = S.length
      fromIndex =
        fromIndex === undefined ? len - 1 : fromIndex
      for (let i = fromIndex; i >= 0; i--) {
        if (S[i] === C) return i
      }
      return -1
    }

    /**
     * 上面的搜索存在这许多重复，我们考虑能否保存关键信息，从而不用对每个位置进行左右扫描
     */

    /**
     * 找到关键保存出现的关键位置，每个元素只用和关键位置比较就好饿
     * 时间 $O(N*M)$
     */
    function solution2(S, C) {
      const len = S.length,
        indexArr = [],
        ans = []

      for (let i = 0; i < len; i++) {
        if (S[i] === C) indexArr.push(i)
      }
      for (let i = 0; i < len; i++) {
        // distance
        let dist = Infinity
        for (const index of indexArr) {
          let temp = Math.min(dist, Math.abs(i - index))
          // 如果当前的距离在增大，就不用再接着判断了
          if (dist !== Infinity && temp >= dist) break
          dist = temp
        }
        ans[i] = dist
      }
      return ans
    }

    /**
     * 最终想拿到的效果 ans[i] = i - indexArr[i]
     * 即 indexArr[i] 保存着距离最近的C字符的位置，没有标记为Infinity
     * 时间 $O(3N)$ $O(N)$
     * 空间 $O(3N)$ $O(N)$ 空间这里可以再优化 只使用一个数组就好
     */
    function solution3(S, C) {
      const len = S.length,
        indexArrFromLeft = [],
        indexArrFromRight = [],
        ans = []
      // 从左到右，寻找距离i左边最近的C的位置
      for (let i = 0; i < len; i++) {
        if (S[i] === C) {
          indexArrFromLeft[i] = i
        } else {
          indexArrFromLeft[i] =
            indexArrFromLeft[i - 1] === void 0
              ? Infinity
              : indexArrFromLeft[i - 1]
        }
      }

      // 从右边到左边，寻找距离i右边最近的C的位置
      for (let i = len - 1; i >= 0; i--) {
        if (S[i] === C) {
          indexArrFromRight[i] = i
        } else {
          indexArrFromRight[i] =
            indexArrFromRight[i + 1] === void 0
              ? Infinity
              : indexArrFromRight[i + 1]
        }
      }

      // 得出我们最终需要的 保存着距离最近（左右均包含）的C字符的位置
      for (let i = 0; i < len; i++) {
        ans[i] = Math.min(
          Math.abs(indexArrFromLeft[i] - i),
          Math.abs(indexArrFromRight[i] - i)
        )
      }
      return ans
    }

    // 滑动窗口
    // 关键点是确定一个又一个的小区间，在这个区间里度量距离各个位置的距离
    /**
     * @param {string} S
     * @param {character} C
     * @return {number[]}
     */
    function solution4(S, C) {
      let l = S[0] === C ? 0 : Infinity,
        r = S.indexOf(C, 1)
      const len = S.length,
        ans = []
      for (let i = 0; i < len; i++) {
        ans[i] = Math.min(Math.abs(i - l), Math.abs(i - r))
        if (i === r) {
          l = r
          r = S.indexOf(C, r + 1)
        }
      }
      return ans
    }
    console.log(shortestToChar("loveleetcode", "e"))
    console.log(solution2("loveleetcode", "e"))
    console.log(solution3("loveleetcode", "e"))
    console.log(solution4("baaa", "b"))
  </script>
</body>
