<body>
  <script>
    /**
     * @param {string} S
     * @param {character} C
     * @return {number[]}
     */
    // var shortestToChar = function (S, C) {
    //   const ans = []
    //   for (let i = 0; i < S.length; i++) {
    //     ans[i] = Math.min(
    //       S.lastIndexOf(C, i) === -1
    //         ? Infinity
    //         : i - S.lastIndexOf(C, i),
    //       S.indexOf(C, i) === -1
    //         ? Infinity
    //         : S.indexOf(C, i) - i
    //     )
    //   }
    //   return ans
    // }

    var shortestToChar = function (S, C) {
      const indexArr = [],
        len = S.length,
        ans = Array(len).fill(len)
      for (let i = 0; i < len; i++) {
        if (S[i] === C) indexArr.push(i)
      }
      for (let i = 0; i < len; i++) {
        if (S[i] === C) {
          ans[i] = 0
          continue
        }
        for (const index of indexArr) {
          const dist = Math.abs(index - i)

          if (dist >= ans[i]) break
          ans[i] = dist
        }
      }
      return ans
    }

    // 这里取巧用了api，尝试自己写个indexOf & lastIndexOf
    function myIndexOf(S, C, fromIndex = 0) {
      const len = S.length
      for (let i = fromIndex; i < len; i++) {
        if (S[i] === C) return i
      }
      return -1
    }

    function myLastIndexOf(S, C, fromIndex) {
      const len = S.length
      fromIndex =
        fromIndex === undefined ? len - 1 : fromIndex
      for (let i = fromIndex; i >= 0; i--) {
        if (S[i] === C) return i
      }
      return -1
    }

    /**
     * 上面的搜索存在这许多重复，我们考虑能否保存关键信息，从而不用对每个位置进行左右扫描
     */

    /**
     * 找到关键保存出现的关键位置，每个元素只用和关键位置比较就好饿
     * 时间 $O(N*M)$
     */
    function solution2(S, C) {
      const len = S.length,
        indexArr = [],
        ans = []

      for (let i = 0; i < len; i++) {
        if (S[i] === C) indexArr.push(i)
      }
      console.log(indexArr)
      for (let i = 0; i < len; i++) {
        // distance
        let dist = Infinity
        for (const index of indexArr) {
          let temp = Math.min(dist, Math.abs(i - index))
          // 如果当前的距离在增大，就不用再接着判断了
          if (dist !== Infinity && temp >= dist) break
          dist = temp
        }
        ans[i] = dist
      }
      return ans
    }

    /**
     * 最终想拿到的效果 ans[i] = i - indexArr[i]
     * 即 indexArr[i] 保存着距离最近的C字符的位置，没有标记为Infinity
     */
    function solution3(S, C) {
      const len = S.length,
        indexArr = [],
        ans = []
      // 从左到右，寻找距离i左边最近的C的位置
      for (let i = 0; i < len; i++) {
        if (S[i] === C) {
          indexArr[i] = i
        } else {
          indexArr[i] =
            indexArr[i - 1] === void 0
              ? Infinity
              : indexArr[i - 1]
        }
      }
      /**
       * 两种情况
       *
       */
      for (let i = len - 1; i >= 0; i--) {
        if (indexArr[i - 1] > indexArr[i + 1]) {
          indexArr[i] = indexArr[i + 1]
        }
      }
    }
    console.log(shortestToChar("loveleetcode", "e"))
    console.log(solution2("loveleetcode", "e"))
  </script>
</body>
