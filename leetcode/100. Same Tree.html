<body>
  <script>
    /**
     * @param {TreeNode} p
     * @param {TreeNode} q
     * @return {boolean}
     */
    var isSameTree = function (p, q) {
      if (!p || !q) {
        return !p && !q
      }
      return (
        p.val === q.val &&
        isSameTree(p.left, q.left) &&
        isSameTree(p.right, q.right)
      )
    }

    // 如何确定一个树？ 前后可以用来确定根 还需要呀中序遍历来确定左右子树
    // 下面的写法感觉已经很perfect的了，学到临时变量的一招
    const isSameTree = function (p, q) {
      var isSameTree = function (p, q) {
        const preorderP = preorder(p, [])
        const preorderQ = preorder(q, [])
        const inorderP = inorder(p, [])
        const inorderQ = inorder(q, [])
        return (
          preorderP.join("") === preorderQ.join("") &&
          inorderP.join("") === inorderQ.join("")
        )
      }

      function preorder(root, arr) {
        if (root === null) {
          arr.push(" ")
          return arr
        }
        arr.push(root.val)
        preorder(root.left, arr)
        preorder(root.right, arr)
        return arr
      }

      function inorder(root, arr) {
        if (root === null) {
          arr.push(" ")
          return arr
        }
        inorder(root.left, arr)
        arr.push(root.val)
        inorder(root.right, arr)
        return arr
      }
    }
  </script>
</body>
