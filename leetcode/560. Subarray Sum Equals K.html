<!--
 * @Author: SedationH
 * @Date: 2020-07-10 11:01:18
 * @LastEditTime: 2020-07-10 11:42:17
 * @FilePath: /learn-algorithm/leetcode/560. Subarray Sum Equals K.html
-->

<body>
  <script>
    /**
     * @param {number[]} nums
     * @param {number} k
     * @return {number}
     */
    var subarraySum = function (nums, k) {
      // 我们使用的前缀和只关心值和出现的次数
      // 代表前缀和为0的出现了一次
      const preSum = {
        0: 1,
      }
      let curSum = 0,
        ans = 0
      for (let i = 0; i < nums.length; i++) {
        curSum += nums[i]
        if (preSum[curSum - k] !== undefined) {
          ans += preSum[curSum - k]
        }
        if (preSum[curSum] !== undefined) {
          preSum[curSum]++
        } else {
          preSum[curSum] = 1
        }
      }

      return ans
    }

// 超时
var subarraySum = function (nums, k) {
  const prefixes = [],
    len = nums.length
  prefixes[-1] = 0
  let currSum = 0,
    ans = 0
  for (let i = 0; i < len; i++) {
    currSum += nums[i]
    prefixes[i] = currSum
  }
  for (let i = -1; i < len; i++) {
    for (let j = i + 1; j < len; j++) {
      const sub = prefixes[j] - prefixes[i]
      if (sub === k) {
        ans++
      }
      // 不能这么写 范围在[-10^7,10^7]
      // else if (sub > k) {
      //   break
      // }
    }
  }
  return ans
}

/**
  * @param {number[]} nums
  * @param {number} k
  * @return {number}
  */
var subarraySum = function (nums, k) {
  // 关键信息 连续的subarrays 值等于k

  // 定义cache[value] 为当前使用索引前 从[0, 当前i]中值为value的个数
  const cache = {
      0: 1,
    },
    len = nums.length
  let prefix = 0,
    ans = 0
  for (let i = 0; i < len; i++) {
    prefix += nums[i]
    if (prefix - k in cache) {
      ans += cache[prefix - k]
    }
    cache[prefix] = (cache[prefix] || 0) + 1
  }
  return ans
}

// 思考的内容
//   有重复计算 如何优化？ -> prefix
//   有低效率的查询 如何优化 -> cache/map

    console.log(subarraySum([1, 1, 0, 1, 2], 2))
  </script>
</body>
