<!--
 * @Author: SedationH
 * @Date: 2020-07-26 21:25:24
 * @LastEditTime: 2020-07-26 23:57:38
 * @FilePath: /learn-algorithm/leetcode/329. Longest Increasing Path in a Matrix.html
-->

<body>

  <script>
    /**
     * @param {number[][]} matrix
     * @return {number}
     */
    var longestIncreasingPath = function (matrix) {
      if (matrix.length === 0) return 0
      let ans = 1, cnt = 1
      const
        // 定义dp[i][j] 为到达该i,j点所能达到的最大步数
        dp = Array.from({ length: matrix.length }, () => Array(matrix[0].length).fill(0)),
        dir = [
          [1, 0], [0, 1], [-1, 0], [0, -1]
        ]
      /**
       * 枚举每一个点作为起始点，进行dfs，记录此时最大值
       */
      for (let i = 0; i < matrix.length; i++) {
        for (let j = 0; j < matrix[i].length; j++) {
          ans = Math.max(ans, dfs(i, j))
        }
      }

      return ans

      /**
       * 产品法
       *  产品
       *    dfs(x,y) 获得x,y点的能够达到的最大值
       *  子问题
       *    [x,y]上下左右的最值
       *  大小问题关系
       *    [x,y]比周围isVaild的点的最值大一就好
       *  边界
       *    没得比，那就自己变为1
       */
      function dfs(x, y) {
        /**
         * 向上右下左四个方向走
         */
        if (dp[x][y] !== 0) return dp[x][y]
        let nextX, nextY, maxStep = 1
        for (let i = 0; i < 4; i++) {
          nextX = x + dir[i][0]
          nextY = y + dir[i][1]
          if (isValid(nextX, nextY) && matrix[nextX][nextY] > matrix[x][y]) {
            dfs(nextX, nextY)
            // 只要比周围的四个之中的有效点中的最大值大一就好了
            maxStep = Math.max(maxStep, dp[nextX][nextY] + 1)
          }
        }
        return dp[x][y] = maxStep
      }

      function isValid(x, y) {
        return x >= 0 && x < matrix.length && y >= 0 && y <= matrix[0].length
      }
    }

    var TIMEOUTsolution = function (matrix) {
      if (matrix.length === 0) return 0
      let ans = 1, cnt = 1
      let flag = Array.from({ length: matrix.length }, () => Array(matrix[0].length).fill(0))
      /**
       * 枚举每一个点作为起始点，进行dfs，记录此时最大值
       */
      for (let i = 0; i < matrix.length; i++) {
        for (let j = 0; j < matrix[i].length; j++) {
          dfs(i, j)
        }
      }

      return ans

      /**
       * 将所给点作为起始点进行深度优先遍历，返回所走长度
       */
      function dfs(x, y) {
        /**
         * 向上右下左四个方向走
         */
        const dir = [
          [1, 0], [0, 1], [-1, 0], [0, -1]
        ]
        let nextX, nextY
        for (let i = 0; i < 4; i++) {
          nextX = x + dir[i][0]
          nextY = y + dir[i][1]
          if (isValid(nextX, nextY) && matrix[nextX][nextY] > matrix[x][y]) {
            flag[nextX][nextY] = 1
            cnt++
            ans = Math.max(cnt, ans)
            dfs(nextX, nextY)
            flag[nextX][nextY] = 0
            cnt--
          }
        }
      }

      function isValid(x, y) {
        return x >= 0 && x < matrix.length && y >= 0 && y <= matrix[0].length && flag[x][y] === 0
      }

    };

    console.log(
      longestIncreasingPath(
        [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [19, 18, 17, 16, 15, 14, 13, 12, 11, 10], [20, 21, 22, 23, 24, 25, 26, 27, 28, 29], [39, 38, 37, 36, 35, 34, 33, 32, 31, 30], [40, 41, 42, 43, 44, 45, 46, 47, 48, 49], [59, 58, 57, 56, 55, 54, 53, 52, 51, 50], [60, 61, 62, 63, 64, 65, 66, 67, 68, 69], [79, 78, 77, 76, 75, 74, 73, 72, 71, 70], [80, 81, 82, 83, 84, 85, 86, 87, 88, 89], [99, 98, 97, 96, 95, 94, 93, 92, 91, 90], [100, 101, 102, 103, 104, 105, 106, 107, 108, 109], [119, 118, 117, 116, 115, 114, 113, 112, 111, 110], [120, 121, 122, 123, 124, 125, 126, 127, 128, 129], [139, 138, 137, 136, 135, 134, 133, 132, 131, 130], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]
      )
    )
  </script>
</body>