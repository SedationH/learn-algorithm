<body>
  <div style="white-space: pre;">
    <h1>分析的太好了 555</h1>
    <h2>再结合一下减治就可以AC 😊</h2>
  首先说一下主要思路：

  单调递增的序列：
  
          *
        *
      *
    *
  *
  做了旋转：
  
    *
  *
          *
        *
      *
  用二分法查找，需要始终将目标值（这里是最小值）套住，并不断收缩左边界或右边界。
  
  左、中、右三个位置的值相比较，有以下几种情况：
  
  左值 < 中值, 中值 < 右值 ：没有旋转，最小值在最左边，可以收缩右边界
  
          右
       中
   左
  左值 > 中值, 中值 < 右值 ：有旋转，最小值在左半边，可以收缩右边界
  
   左       
           右
       中
  左值 < 中值, 中值 > 右值 ：有旋转，最小值在右半边，可以收缩左边界
  
       中  
   左 
           右
  左值 > 中值, 中值 > 右值 ：单调递减，不可能出现
  
   左
      中
          右
  分析前面三种可能的情况，会发现情况1、2是一类，情况3是另一类。
  
  如果中值 < 右值，则最小值在左半边，可以收缩右边界。
  如果中值 > 右值，则最小值在右半边，可以收缩左边界。
  通过比较中值与右值，可以确定最小值的位置范围，从而决定边界收缩的方向。
  
  而情况1与情况3都是左值 < 中值，但是最小值位置范围却不同，这说明，如果只比较左值与中值，不能确定最小值的位置范围。
  <hr>
(题解已修改，这个评论值得注意下⚠️)
  你好！看了你这篇题解感觉对二分法理解更透彻了！不过在左中右大小讨论的情况2我觉得应该是错的

      右
  左 
    中
我认为除了数组本身未旋转这种情况外，在其他所有已经旋转了的数组中都存在这样一种关系：nums[左] 恒大于nums[右] 。
理由：数组是升序排列的，旋转点的数字恒大于旋转点的前一个数字，而前者和后者分别成为旋转后数组的左边和右边。
  
  作者：armeria-program
  链接：https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/solution/er-fen-cha-zhao-wei-shi-yao-zuo-you-bu-dui-cheng-z/
  来源：力扣（LeetCode）
  著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
  </div>
  <script>
    var findMin1 = function (nums) {
      let left = 0, right = nums.length - 1
      if (right === 0) {
        return nums[0]
      }
      nums.push(Infinity)
      while (left < right) {
        let mid = Math.floor((left + right) / 2)
        if (nums[mid] > nums[right]) {
          left = mid + 1
        } else {
          right = mid
        }
        if (nums[mid + 1] - nums[mid] < 0) {
          return nums[mid + 1]
        }
      }
      return nums[0]
    };

    var findMin2 = function (nums) {
      let left = 0, right = nums.length - 1
      while (left < right) {
        let mid = Math.floor((left + right) / 2)
        if (nums[mid] > nums[right]) {
          // 通过这里跳出的时候，条件的含义是最后一个满足nums[mid] > nums[right]的元素
          // mid+1后就是我们寻找的位置
          left = mid + 1
        } else {
          right = mid
        }
      }
      return nums[left]
    };

    // 减治逻辑思考，分别思考两个比对方案可行与否，然后进行规模缩减
    var findMin = function (nums) {
      const len = nums.length
      let left = 0, right = len - 1
      while (left < right) {
        const mid = Math.floor(left + (right - left) / 2)

        // 看什么逻辑可以帮助我们有效缩小问题规模
        if (nums[right] < nums[mid]) {
          left = mid + 1
        } else {
          right = mid
        }
      }
      return nums[left]
    }

    console.log(
      findMin(
        [4, 5, 6, 7, -1, 1, 2]
      ),
      findMin2(
        [4, 5, 6, 7, 0, 1, 2]
      )
    )
  </script>
</body>