<!--
 * @Author: SedationH
 * @Date: 2020-07-10 18:18:10
 * @LastEditTime: 2020-07-10 19:58:26
 * @FilePath: /learn-algorithm/leetcode/1371. Find the Longest Substring Containing Vowels in Even Counts.html
-->

<body>
  链接：https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/solution/jiang-ti-mu-yi-bu-bu-deng-jie-zhuan-hua-fei-qi-ji-/
  <script>
    // 前缀和
    var findTheLongestSubstring = function (s) {
      // 用来保存第一次出现某种状态的时候 对应的位置
      // [i,j]中元音满足 等价于 [0,j]的state - [0,i-1]的state
      // 为了处理当i等于0的边界情况，引入-1,让初始状态在-1位置存在
      const prefixState = {
        0: -1,
      }
      // 元音字母表用于异或 ^
      /**
       * a: 00001
       * b: 00010 ...
       */
      const vowel = {
        a: 1,
        e: 2,
        i: 4,
        o: 8,
        u: 16,
      }
      // 记录此时的状态
      let state = 0,
        ans = 0
      for (let i = 0; i < s.length; i++) {
        const char = s[i]
        // 当此时的字符为元音字母的时候，更改状态
        if (vowel[char] !== undefined) {
          state ^= vowel[char]
          // 如果这个状态是第一次出现，就进行记录，因为是求最远的距离，所以只用记录第一次就好
          if (prefixState[state] === undefined) {
            prefixState[state] = i
          }
        }
        ans = Math.max(ans, i - prefixState[state])
      }
      return ans
    }

    // 暴力法
    var solution = function (s) {
      // 区间长度
      for (let i = s.length; i > 0; i--) {
        // 选择开始位置，根据结尾index卡范围
        for (let j = 0; j + i - 1 <= s.length; j++) {
          const sub = s.substring(j, j + i)
          // 暴力枚举其中元音字母的个数
          let isEven = true
          const choose = ['a', 'e', 'i', 'o', 'u']
          for (const e of choose) {
            if ((sub.split(e).length - 1) % 2 !== 0) {
              isEven = false
            }
          }
          if (isEven) {
            return i
          }
        }
      }
    }

    /**
     * @param {string} s
     * @return {number}
     */
    var findTheLongestSubstring = function (s) {
      // 完全独立完成

      const len = s.length,
        // 规定 a e i o u
        // 通过位运算来解决数据状态存储和状态变化问题
        map = {
          a: 0b10000,
          e: 0b01000,
          i: 0b00100,
          o: 0b00010,
          u: 0b00001,
        },
        prefix = []
      prefix[-1] = 0b00000
      let state = 0b00000
      for (let i = 0; i < len; i++) {
        state ^= map[s[i]]
        prefix.push(state)
      }
      // 从最大可能开始寻找
      // 外层控制区间长度 内层控制最后边界位置
      for (let i = len; i >= 1; i--) {
        for (let j = len - 1; j - i >= -1; j--) {
          const tempState = prefix[j] ^ prefix[j - i]
          // only 0 0 -> 0 | 1 1 -> 0
          if (!tempState) return i
        }
      }
      return 0
    }

    /**
     * @param {string} s
     * @return {number}
     */
    var findTheLongestSubstring = function (s) {
      const len = s.length,
        // 规定 a e i o u
        // 通过位运算来解决数据状态存储和状态变化问题
        map = {
          a: 0b10000,
          e: 0b01000,
          i: 0b00100,
          o: 0b00010,
          u: 0b00001,
        },
        prefix = {
          0: -1,
        }
      let state = 0b00000,
        ans = 0
      // 对每个状态进行最远距离求取，这个遍历过程中
      // 把出现的状态仅仅记录一次，不断更新ans即可
      for (let i = 0; i < len; i++) {
        const char = s[i]
        if (map[char] !== undefined) {
          state ^= map[char]
          // 如果是第一次出现
          // 被这里 prefix[state] === 0的可能坑了好久，强制类型的重要性
          if (prefix[state] === undefined) {
            // 这个行为和 0: -1的设定是一致的
            prefix[state] = i
          }
        }

        // ⚠️这里对开始的处理为 0: -1 那么对于第一个不是vowel的情况
        // 0 - -1 = 1
        ans = Math.max(ans, i - prefix[state])
      }
      return ans
    }

    console.log(findTheLongestSubstring('a'))
  </script>
</body>
